!macro inc_vic_control_y {
    lda VIC_CONTROL_Y                       ;  4
    clc                                     ;  2
    adc #1                                  ;  2
    and #%00000111                          ;  2
    adc #CONTROL_Y_INVALID                  ;  2
    sta VIC_CONTROL_Y                       ;  4
}                                           ;--> 16

!warn "bytes wasted: ", IRQ-*

!align 255, 0
IRQ !zone {
;-------------------------------------------------------------------------------
;   LINE_0
;-------------------------------------------------------------------------------

    ; irq event                             ;  7
    ; last instruction                      ;  1 (min)
    +save_regs .out_0                       ; 12
                                            ;--> 20

    ; ack interrupt
    inc VIC_IRQ_STATUS                      ;  6

    inc VIC_RASTER                          ;  6
    +set16 .irq_line_0_plus_1, VECTOR_IRQ   ; 12
                                            ;--> 24

    ; save stack state
    tsx                                     ;  2
    +wait 3                                 ;  3
    ; begin raster stabilization
    cli                                     ;  2
                                            ;--> 7

    ; somewhere here the next interrupt will hit
    +wait 63 - 20 - 24 - 7

;-------------------------------------------------------------------------------
;   LINE_0 + 1
;-------------------------------------------------------------------------------
.irq_line_0_plus_1
    ; irq event                             ;  7
    ; last instruction                      ;1-2 (because of the nop field above)
    ; restore stack state
    txs                                     ;  2
                                            ;--> 10-11

    ; calculate the number of nops to skip in VSP
    lda #39                                 ;  2
    sec                                     ;  2
HARD_X = *+1
    sbc #0                                  ;  2
    lsr                                     ;  2
    sta .self_modifying_branch__nops + 1    ;  4
                                            ;--> 12

    ; introduce an extra cycle in VSP if carry is set
    bcs .set_bcc                            ;2-3
.set_bcs
    ldx #BCS_OPCODE                         ;  2
    bne +   ; always true                   ;  3
.set_bcc
    ldx #BCC_OPCODE                         ;  2
    nop     ; make this path as long        ;  2
+
    stx .self_modifying_branch__lsb         ;  4
                                            ;--> 11

    ; set up soft scroll
    lda #CONTROL_X                          ;  2
    clc                                     ;  2
SOFT_X = *+1
    adc #0                                  ;  2
    sta VIC_CONTROL_X                       ;  4
                                            ;--> 10

    ; switch to VIC bank 0
    ;inc CIA2_DATA_PORT_A                    ;  6
    inc $ff00

    +wait 63-11-12-11-10-6-6

    ; wobble check
    lda #LINE_0 + 2                         ;  2
    cmp VIC_RASTER                          ;  4
                                            ;--> 6
    +bne                                    ;3-2
    ; -> the raster interrupt is stable now with 3 cycles off

;-------------------------------------------------------------------------------
;   LINE_0 + 2
;-------------------------------------------------------------------------------

    ; wobble check from above               ;-->  3

    ; make FIRST_BADLINE a bad line
    lda #CONTROL_Y_INVALID                  ;  2
    sta VIC_CONTROL_Y                       ;  4
                                            ;-->  6

    lda #25                                 ;  2
    sec                                     ;  2
HARD_Y = *+1
    sbc #0                                  ;  2
    tax                                     ;  2
                                            ;-->  8

    ; pre-compute VIC_CONTROL_Y value for soft-scrolling
    lda #7 + (25+1) % 8                     ;  2
    sec                                     ;  2
SOFT_Y = *+1
    sbc #0                                  ;  2

    and #%00000111                          ;  2
    ora #CONTROL_Y_INVALID                  ;  2
    ; spill pre-computed value
    sta TMP_CONTROL_Y                       ;  3
                                            ;--> 13

    ;wait till just before LINE_O + 3 == FIRST_BADLINE
    +wait_loop 63 - 3 - 6 - 8 - 13 - 20 - 4

;-------------------------------------------------------------------------------
;   FLD & line crunch
;-------------------------------------------------------------------------------

.fld_loop
    cpx #0                                  ;  2
    beq +                                   ;  2 (in this loop)
    +inc_vic_control_y                      ; 16
                                            ;--> 20
    +wait_loop 63 - 20 - 2 - 3
    dex                                     ;  2
    jmp .fld_loop                           ;  3
+

    ldx HARD_Y

.crunch_loop
    cpx #0                                  ;  2
    beq +                                   ;  2 (in this loop)
    +inc_vic_control_y                      ; 16
                                            ;--> 20

    +wait 63 - 20 - 2 - 3
    dex                                     ;  2
    jmp .crunch_loop                        ;  3
+

    ; ^^^ these are always 25 raster lines ^^^

;-------------------------------------------------------------------------------
;   VSP
;-------------------------------------------------------------------------------
    ; make VSP line not a bad line
    inc VIC_CONTROL_Y
    +wait 5
    sec
    ; introduce an extra cycle if 39 - HARD_X is odd
.self_modifying_branch__lsb
    +bcs                                    ;2-3

.self_modifying_branch__nops
    ; always true and jump into nop field
    +bcs                                    ;  3
    +wait 38                                ;0-38

!if (>IRQ) != (>*) {
    !error "critical irq code in different pages"
}
    ; generate bad line
    dec VIC_CONTROL_Y

;-------------------------------------------------------------------------------
; soft scroll
;-------------------------------------------------------------------------------

    ; reload pre-computed VIC_CONTROL_Y value
    lda TMP_CONTROL_Y
    sta VIC_CONTROL_Y
    and #CONTROL_Y_MASK
    sta TMP_CONTROL_Y

    ;inc VIC_BORDER
    ldx #$00
    jsr DISPLAY_SPRITE_STRIP
    ;dec VIC_BORDER

    ;ldx CIA2_DATA_PORT_A
    ;dex

    lda TMP_CONTROL_Y
    ; wait till end of AGSP region
    ldy #FIRST_BADLINE+25+8
-
    cpy VIC_RASTER
    bne -

    ;stx CIA2_DATA_PORT_A
    ;stx $ff00
    sta VIC_CONTROL_Y

;-------------------------------------------------------------------------------
; sprite multiplexing
;-------------------------------------------------------------------------------

    ;dec VIC_BORDER
    ;ldx #$00
    ;jsr DISPLAY_SPRITE_STRIP
    ;dec VIC_BORDER
    +set16 .strip_1, VECTOR_IRQ
.out_0
    +ack_restore_rti

.strip_1
    +save_regs .out_1
    inc VIC_BORDER
    ldx #$04
    jsr DISPLAY_SPRITE_STRIP
    dec VIC_BORDER
    +set16 .strip_2, VECTOR_IRQ
.out_1
    +ack_restore_rti

.strip_2
    +save_regs .out_2
    inc VIC_BORDER
    ldx #$08
    jsr DISPLAY_SPRITE_STRIP
    dec VIC_BORDER
    +set16 .strip_3, VECTOR_IRQ
.out_2
    +ack_restore_rti

.strip_3
    +save_regs .out_3
    inc VIC_BORDER
    ldx #$0c
    jsr DISPLAY_SPRITE_STRIP
    dec VIC_BORDER
    +set_raster_line_8 LINE_0
    +set16 IRQ, VECTOR_IRQ
    jsr JOY
    +wait_loop 63 * 8
    inc VIC_BORDER
    jsr SPR_SORT
    dec VIC_BORDER
.out_3
    +ack_restore_rti
EMPTY_INTERRUPT = *-1
}

!macro rol2 .addr {
    php
    rol .addr
    plp
    rol .addr
}


!zone {
!warn "bytes wasted: ", .x_msb_table-*
!align 255, 0
.x_msb_table
    !by %00000000, %00000011, %00001100, %00001111
    !by %00110000, %00110011, %00111100, %00111111
    !by %11000000, %11000011, %11001100, %11001111
    !by %11110000, %11110011, %11111100, %11111111

DISPLAY_SPRITE_STRIP 
    +set 0, TMP_SPR_X_MSB
    !for .i, 0, 3 {
        !set .r = 3-.i
        ; index
        ldy SPR_I + .i, x

        ; y-coord
        lda SPR_Y, y
        asl
        sta VIC_SPR_0_Y + 4*.r
        sta VIC_SPR_0_Y + 4*.r + 2

        ; x-coord
        lda SPR_X, y
        asl
        rol TMP_SPR_X_MSB
        sta VIC_SPR_0_X + 4*.r
        sta VIC_SPR_0_X + 4*.r + 2
    
        ; colors
        lda SPR_A, y
        sta VIC_SPR_0_COLOR + .r*2
        lda SPR_B, y
        sta VIC_SPR_0_COLOR + .r*2 + 1

        ; set sprite pointers
        lda SPR_F, y
        sta SPR_PTR + .r*2 + 1
        clc
        adc #1
        sta SPR_PTR + .r*2
    }

    ; fist y of next strip
    ldy SPR_I + 4, x
.ld_index=*-1
    lda SPR_Y, y
    asl
    sec
    sbc #7
    +set_raster_line_8

    ldx TMP_SPR_X_MSB
    lda .x_msb_table, x
.ld_x_msb_table=*-1
    sta VIC_SPR_X_MSB

    rts

    !if >.ld_x_msb_table != >.x_msb_table {
        !error ".ld_x_msb_table and .x_msb_table in different pages"
    }
}

SPR_SORT !zone {
    ; merge sort

    ; first sort all pairs
    !for .i, 0, 7 {
        ldx SPR_I + .i*2
        ldy SPR_I + .i*2 + 1
        lda SPR_Y, y    ; A: r-elem
        cmp SPR_Y, x    ; M: l-elem
        ; swap if A < M 
        ; skip if A >= M
        +buge +
        sty SPR_I + .i*2
        stx SPR_I + .i*2 + 1
+
    }

    !macro merge .l, .r, .num {
        lda #.l
        sta SORT_L
        lda #.r
        sta sort_l_end
        sta SORT_R
        lda #.r + .num
        sta sort_r_end
        jsr merge_sort
    }

    +merge  0,  2, 2
    +merge  4,  6, 2
    +merge  8, 10, 2
    +merge 12, 14, 2
    +merge  0,  4, 4
    +merge  8, 12, 4
    +merge  0,  8, 8
    rts

.swap_inc_j
    ; swap
    ; y still holds SORT_L
    ; x still holds l-index
    stx TMP_I_L     ; spill old l-index

    ; l-index := r-index
    ldx SORT_R
    lda SPR_I, x 
    sta SPR_I, y

    ; r-index := old l-index
    lda TMP_I_L
    sta SPR_I, x

sort_r_end=*+1
    lda #0
    sec
    isc SORT_R
    beq .out

merge_sort
    ldy SORT_R
    ldx SPR_I, y
    lda SPR_Y, x    ; A: r-elem

    ldy SORT_L
    ldx SPR_I, y
    cmp SPR_Y, x    ; M: l-elem
    ; swap if A < M 
    +bult .swap_inc_j

sort_l_end=*+1
    lda #0
    sec
    isc SORT_L
    beq .out
    jmp merge_sort
.out
    rts
}

