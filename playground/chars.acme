; copy over softchar (index in X) to (PTR_HIRES_R), (PTR_COLOR_R), (PTR_SCREEN_R)
; destroys: A, Y
COPY_SOFTCHARS_R !zone {
    ; copy over soft char line by line
    ; y is used to index the row

    !for .j, 8 {
    !set .i = .j - 1
        
        !if .i = 0 {
            ldy #7
        } else {
            dey
        }

        lda SOFTCHARS + .i * $100, x
        sta (PTR_HIRES_R), y
    }

    ; y = 0 here

    ; copy over color infos
    lda SOFTCHARS_C, x
    sta (PTR_COLOR_R), y
    lda SOFTCHARS_S, x
    sta (PTR_SCREEN_R), y

    rts
}

; copy over softchar (index in X) to (PTR_HIRES_R), (PTR_COLOR_R), (PTR_SCREEN_R)
; destroys: A, Y
COPY_SOFTCHARS_C !zone {
    ; copy over soft char line by line
    ; y is used to index the row

    !for .j, 8 {
    !set .i = .j - 1
        
        !if .i = 0 {
            ldy #7
        } else {
            dey
        }

        lda SOFTCHARS + .i * $100, x
        sta (PTR_HIRES_C), y
    }

    ; y = 0 here

    ; copy over color infos
    lda SOFTCHARS_C, x
    sta (PTR_COLOR_C), y
    lda SOFTCHARS_S, x
    sta (PTR_SCREEN_C), y

    rts
}

!macro inc_wrap_around_rts_r {
    ; is here a wrap-around of the buffers?
    lda PTR_COLOR_R + 1
    cmp # >(COLOR_RAM + $0400)
    bne +

    ; wrap around
    lda # >HIRES
    sta PTR_HIRES_R + 1

    lda # >SCREEN
    sta PTR_SCREEN_R + 1

    lda # >COLOR_RAM
    sta PTR_COLOR_R + 1
+
    rts
}

!macro inc_wrap_around_rts_c {
    ; is here a wrap-around of the buffers?
    lda PTR_COLOR_C + 1
    cmp # >(COLOR_RAM + $0400)
    bne +

    ; wrap around
    lda # >HIRES
    sta PTR_HIRES_C + 1

    lda # >SCREEN
    sta PTR_SCREEN_C + 1

    lda # >COLOR_RAM
    sta PTR_COLOR_C + 1
+
    rts
}

!macro dec_wrap_around_rts_r {
    ; is here a wrap-around of the buffers?
    lda PTR_COLOR_R + 1
    cmp # >(COLOR_RAM - 1)
    bne +

    ; wrap around
    lda # >(HIRES + $2000 - 8)
    sta PTR_HIRES_R + 1

    lda # >(SCREEN + $0400 - 1)
    sta PTR_SCREEN_R + 1

    lda # >(COLOR_RAM + $0400 - 1)
    sta PTR_COLOR_R + 1
+
    rts
}

!macro dec_wrap_around_rts_c {
    ; is here a wrap-around of the buffers?
    lda PTR_COLOR_C + 1
    cmp # >(COLOR_RAM - 1)
    bne +

    ; wrap around
    lda # >(HIRES + $2000 - 8)
    sta PTR_HIRES_C + 1

    lda # >(SCREEN + $0400 - 1)
    sta PTR_SCREEN_C + 1

    lda # >(COLOR_RAM + $0400 - 1)
    sta PTR_COLOR_C + 1
+
    rts
}

; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one char postion
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
INC_SCROLL_PTRS_R !zone {
    lda PTR_HIRES_R
    clc
    adc #8
    sta PTR_HIRES_R
    bcc .out_safely_inc_others  

    inc PTR_HIRES_R + 1   ; add carry to high byte

    ; PTR_SCREEN and PTR_COLOR _may_ overflow
    inc PTR_SCREEN_R
    inc PTR_COLOR_R

    ; do PTR_SCREEN and PTR_COLOR overflow, too?
    bne .out

    inc PTR_SCREEN_R + 1
    inc PTR_COLOR_R + 1

    +inc_wrap_around_rts_r

.out_safely_inc_others

    ; PTR_SCREEN and PTR_COLOR _cannot_ overflow
    inc PTR_SCREEN_R
    inc PTR_COLOR_R

.out
    rts
}

; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one char postion
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
INC_SCROLL_PTRS_C !zone {
    lda PTR_HIRES_C
    clc
    adc #8
    sta PTR_HIRES_C
    bcc .out_safely_inc_others  

    inc PTR_HIRES_C + 1   ; add carry to high byte

    ; PTR_SCREEN and PTR_COLOR _may_ overflow
    inc PTR_SCREEN_C
    inc PTR_COLOR_C

    ; do PTR_SCREEN and PTR_COLOR overflow, too?
    bne .out

    inc PTR_SCREEN_C + 1
    inc PTR_COLOR_C + 1

    +inc_wrap_around_rts_c

.out_safely_inc_others

    ; PTR_SCREEN and PTR_COLOR _cannot_ overflow
    inc PTR_SCREEN_C
    inc PTR_COLOR_C

.out
    rts
}

ADD_SCROLL_PTRS_R !zone {
    tax
    inc PTR_HIRES_R + 1   ; + 256
    ; add to low byte: A * 8 - 256 = 8 * (A - 32)
    sec
    sbc #32
    asl
    asl
    asl
    clc
    adc PTR_HIRES_R
    sta PTR_HIRES_R
    bcc +
    inc PTR_HIRES_R + 1   ; add carry to high byte
+
    txa
    adc PTR_SCREEN_R      ; carry still clear
    sta PTR_SCREEN_R
    txa
    clc
    adc PTR_COLOR_R
    sta PTR_COLOR_R

    ; do PTR_SCREEN and PTR_COLOR overflow, too?
    bcc .out

    inc PTR_SCREEN_R + 1
    inc PTR_COLOR_R + 1

    +inc_wrap_around_rts_r

.out
    rts
}

ADD_SCROLL_PTRS_C !zone {
    tax
    inc PTR_HIRES_C + 1   ; + 256
    ; add to low byte: A * 8 - 256 = 8 * (A - 32)
    sec
    sbc #32
    asl
    asl
    asl
    clc
    adc PTR_HIRES_C
    sta PTR_HIRES_C
    bcc +
    inc PTR_HIRES_C + 1   ; add carry to high byte
+
    txa
    adc PTR_SCREEN_C      ; carry still clear
    sta PTR_SCREEN_C
    txa
    clc
    adc PTR_COLOR_C
    sta PTR_COLOR_C

    ; do PTR_SCREEN and PTR_COLOR overflow, too?
    bcc .out

    inc PTR_SCREEN_C + 1
    inc PTR_COLOR_C + 1

    +inc_wrap_around_rts_c

.out
    rts
}
; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one char postion
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
DEC_SCROLL_PTRS_R !zone {
    lda PTR_HIRES_R
    sec
    sbc #8
    sta PTR_HIRES_R
    +bbc .out_safely_dec_others  

    dec PTR_HIRES_R + 1   ; sub borrow from high byte

    ; PTR_SCREEN and PTR_COLOR _may_ underflow
    dec PTR_SCREEN_R
    lda PTR_COLOR_R
    clc
    sbc #0              ; dec A (carry clear)
    sta PTR_COLOR_R
    ; do PTR_SCREEN and PTR_COLOR underflow, too?
    +bbc .out

    dec PTR_SCREEN_R + 1
    dec PTR_COLOR_R + 1

    +dec_wrap_around_rts_r

.out_safely_dec_others

    ; PTR_SCREEN and PTR_COLOR _cannot_ underflow
    dec PTR_SCREEN_R
    dec PTR_COLOR_R

.out
    rts
}

DEC_SCROLL_PTRS_C !zone {
    lda PTR_HIRES_C
    sec
    sbc #8
    sta PTR_HIRES_C
    +bbc .out_safely_dec_others  

    dec PTR_HIRES_C + 1   ; sub borrow from high byte

    ; PTR_SCREEN and PTR_COLOR _may_ underflow
    dec PTR_SCREEN_C
    lda PTR_COLOR_C
    sbc #0              ; dec A (carry clear)
    sta PTR_COLOR_C
    ; do PTR_SCREEN and PTR_COLOR underflow, too?
    +bbc .out

    dec PTR_SCREEN_C + 1
    dec PTR_COLOR_C + 1

    +dec_wrap_around_rts_c

.out_safely_dec_others

    ; PTR_SCREEN and PTR_COLOR _cannot_ underflow
    dec PTR_SCREEN_C
    dec PTR_COLOR_C

.out
    rts
}

; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one line position
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
SUB_SCROLL_PTRS_R !zone {
    tax
    dec PTR_HIRES_R + 1   ; - 256
    ; sub from low byte: A * 8 - 256 = 8 * (A - 32)
    sec
    sbc #32
    asl
    asl
    asl
    +rsub PTR_HIRES_R
    sta PTR_HIRES_R
    +bbc +
    dec PTR_HIRES_R + 1   ; sub borrow from high byte
+
    txa
    +rsub PTR_SCREEN_R
    sta PTR_SCREEN_R
    txa
    eor #$ff
    sec
    adc PTR_COLOR_R
    sta PTR_COLOR_R

    ; do PTR_SCREEN and PTR_COLOR underflow, too?
    +bbc .out

    dec PTR_SCREEN_R + 1
    dec PTR_COLOR_R + 1

    +dec_wrap_around_rts_r

.out
    rts
}

SUB_SCROLL_PTRS_C !zone {
    tax
    dec PTR_HIRES_C + 1   ; - 256
    ; sub from low byte: A * 8 - 256 = 8 * (A - 32)
    sec
    sbc #32
    asl
    asl
    asl
    +rsub PTR_HIRES_C
    sta PTR_HIRES_C
    +bbc +
    dec PTR_HIRES_C + 1   ; sub borrow from high byte
+
    txa
    +rsub PTR_SCREEN_C
    sta PTR_SCREEN_C
    txa
    eor #$ff
    sec
    adc PTR_COLOR_C
    sta PTR_COLOR_C

    ; do PTR_SCREEN and PTR_COLOR underflow, too?
    +bbc .out

    dec PTR_SCREEN_C + 1
    dec PTR_COLOR_C + 1

    +dec_wrap_around_rts_c

.out
    rts
}

!macro split16 .times {
!for .j, .times {
    lsr
    ror R16
}
}

; loads in A tile index (from TILE_X and TILE_Y)
; preservers X
; destroys Y
!macro fetch_tile_index {
    ; A = *(LEVEL + TILE_Y * 64 + TILE_X)
    ; example:
    ; TILE_Y =        001011_01
    ; TILE_Y * 64 = 00001011_01000000
    ;                      A      R16

    lda #0
    sta R16
    lda TILE_Y
    +split16 2
    adc #>LEVEL             ; carry clear
    sta R16 + 1
    ldy TILE_X
.load
    lda (R16), y            ; load tile index
}

; loads in R16 ptr to current tile index (in A)
; preservers X
; destroys A, Y
!macro calc_tile_ptr {
    ; R16 = TILES + A * 16 + 4 * TILE_R
    ; example:
    ; A =          0010_1101
    ; A * 16 = 00000010_11010000
    ;                 A      R16

    ldx #0
    stx R16
    +split16 4
    adc #>TILES             ; carry clear
    sta R16 + 1
    lda TILE_R
    asl
    asl
    adc R16                 ; carry clear
    sta R16
}


DO_U !zone {
    inc VIC_BORDER
    +fetch_tile_index
    +calc_tile_ptr

    ldy TILE_C
    sty R8

!for .j, X_WORKLOAD {
    lax (R16), y            ; load soft char index
    jsr COPY_SOFTCHARS_R

    !if .j != X_WORKLOAD {
        jsr DEC_SCROLL_PTRS_R

        lda R8
        sec
        sbc #1
        and #%00000011
        sta R8
        +bbc +
        +fetch_tile_index
        +calc_tile_ptr
+
        ldy R8
    }

}
    jsr DEC_SCROLL_PTRS_R
    dec VIC_BORDER
    rts
}

DO_D !zone {
    inc VIC_BORDER
    jsr INC_SCROLL_PTRS_R
    +fetch_tile_index
    +calc_tile_ptr
    ldy TILE_C
    iny
    cpy #4
    bne +
    ldy #0
+
    sty R8

!for .j, X_WORKLOAD {
    lax (R16), y            ; load soft char index
    jsr COPY_SOFTCHARS_R

    !if .j != X_WORKLOAD {
        jsr INC_SCROLL_PTRS_R

        ldy R8
        iny
        tya
        and #%00000011
        sty R8
        cpy #4
        bne +
        +fetch_tile_index
        +calc_tile_ptr
        ldy #0
        sty R8
+
    }

}
    dec VIC_BORDER
    rts
}
