; copy over softchar (index in A) to (PTR_HIRES), (PTR_COLOR), (PTR_SCREEN)
; destroys: A, X, Y
COPY_SOFTCHARS !zone {
    ; copy over soft char line by line
    ; y is used to index the row

    !for .j, 8 {
    !set .i = .j - 1
        
        !if .i = 0 {
            ldy #7
        } else {
            dey
        }

        lda SOFTCHARS + .i * $100, x
        sta (PTR_HIRES), y
    }

    ; y = 0 here

    ; copy over color infos
    lda SOFTCHARS_C, x
    sta (PTR_COLOR), y
    lda SOFTCHARS_S, x
    sta (PTR_SCREEN), y

    rts
}

!macro inc_wrap_around_rts {
    ; is here a wrap-around of the buffers?
    lda PTR_COLOR + 1
    cmp # >(COLOR_RAM + $0400)
    bne +

    ; wrap around
    lda # >HIRES
    sta PTR_HIRES + 1

    lda # >SCREEN
    sta PTR_SCREEN + 1

    lda # >COLOR_RAM
    sta PTR_COLOR + 1
+
    rts
}

!macro dec_wrap_around_rts {
    ; is here a wrap-around of the buffers?
    lda PTR_COLOR + 1
    cmp # >(COLOR_RAM - 1)
    bne +

    ; wrap around
    lda # >(HIRES + $2000 - 8)
    sta PTR_HIRES + 1

    lda # >(SCREEN + $0400 - 1)
    sta PTR_SCREEN + 1

    lda # >(COLOR_RAM + $0400 - 1)
    sta PTR_COLOR + 1
+
    rts
}

; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one char postion
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
INC_SCROLL_PTRS !zone {
    lda PTR_HIRES
    clc
    adc #8
    sta PTR_HIRES
    bcc .out_safely_inc_others  

    inc PTR_HIRES + 1   ; add carry to high byte

    ; PTR_SCREEN and PTR_COLOR _may_ overflow
    inc PTR_SCREEN
    inc PTR_COLOR

    ; do PTR_SCREEN and PTR_COLOR overflow, too?
    bne .out

    inc PTR_SCREEN + 1
    inc PTR_COLOR + 1

    +inc_wrap_around_rts

.out_safely_inc_others

    ; PTR_SCREEN and PTR_COLOR _cannot_ overflow
    inc PTR_SCREEN
    inc PTR_COLOR

.out
    rts
}

ADD_SCROLL_PTRS !zone {
    tax
    inc PTR_HIRES + 1   ; + 256
    ; add to low byte: A * 8 - 256 = 8 * (A - 32)
    sec
    sbc #32
    asl
    asl
    asl
    clc
    adc PTR_HIRES
    sta PTR_HIRES
    bcc +
    inc PTR_HIRES + 1   ; add carry to high byte
+
    txa
    adc PTR_SCREEN      ; carry still clear
    sta PTR_SCREEN
    txa
    clc
    adc PTR_COLOR
    sta PTR_COLOR

    ; do PTR_SCREEN and PTR_COLOR overflow, too?
    bcc .out

    inc PTR_SCREEN + 1
    inc PTR_COLOR + 1

    +inc_wrap_around_rts

.out
    rts
}

; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one char postion
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
DEC_SCROLL_PTRS !zone {
    lda PTR_HIRES
    sec
    sbc #8
    sta PTR_HIRES
    +bbc .out_safely_dec_others  

    dec PTR_HIRES + 1   ; sub borrow from high byte

    ; PTR_SCREEN and PTR_COLOR _may_ underflow
    dec PTR_SCREEN
    lda PTR_COLOR
    sbc #0              ; dec A (carry clear)
    sta PTR_COLOR
    ; do PTR_SCREEN and PTR_COLOR underflow, too?
    +bbc .out

    dec PTR_SCREEN + 1
    dec PTR_COLOR + 1

    +dec_wrap_around_rts

.out_safely_dec_others

    ; PTR_SCREEN and PTR_COLOR _cannot_ underflow
    dec PTR_SCREEN
    dec PTR_COLOR

.out
    rts
}

; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one line position
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
SUB_SCROLL_PTRS !zone {
    tax
    dec PTR_HIRES + 1   ; - 256
    ; sub from low byte: A * 8 - 256 = 8 * (A - 32)
    sec
    sbc #32
    asl
    asl
    asl
    +rsub PTR_HIRES
    sta PTR_HIRES
    +bbc +
    dec PTR_HIRES + 1   ; sub borrow from high byte
+
    txa
    +rsub PTR_SCREEN
    sta PTR_SCREEN
    txa
    eor #$ff
    sec
    adc PTR_COLOR
    sta PTR_COLOR

    ; do PTR_SCREEN and PTR_COLOR underflow, too?
    +bbc .out

    dec PTR_SCREEN + 1
    dec PTR_COLOR + 1

    +dec_wrap_around_rts

.out
    rts
}

DO_IT !zone {
    ; y -> col position
    lda (PTR_LEVEL), y      ; load tile index

    tay
    sty TMP_TILE_INDEX
    lax (PTR_TILE), y       ; load soft char index
    jsr COPY_SOFTCHARS
    jsr DEC_SCROLL_PTRS

    inc TMP_TILE_INDEX
    ldy TMP_TILE_INDEX
    lax (PTR_TILE), y       ; load soft char index
    jsr COPY_SOFTCHARS
    jsr DEC_SCROLL_PTRS

    inc TMP_TILE_INDEX
    ldy TMP_TILE_INDEX
    lax (PTR_TILE), y       ; load soft char index
    jsr COPY_SOFTCHARS
    jsr DEC_SCROLL_PTRS

    inc TMP_TILE_INDEX
    ldy TMP_TILE_INDEX
    lax (PTR_TILE), y       ; load soft char index
    jsr COPY_SOFTCHARS
    jsr DEC_SCROLL_PTRS
    ;lda #37
    ;jsr SUB_SCROLL_PTRS

    rts
}


SCROLL_UP !zone {
}
