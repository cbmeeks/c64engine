; copy over softchar (index in A) to (PTR_HIRES), (PTR_COLOR), (PTR_SCREEN)
; destroys: A, X, Y
COPY_SOFTCHARS !zone {
    tax
    
    ; copy over soft char line by line
    ; y is used to index the row

    !for .j, 8 {
    !set .i = .j - 1
        
        !if .i = 0 {
            ldy #7
        } else {
            dey
        }

        lda SOFTCHARS + .i * $100, x
        sta (PTR_HIRES), y
    }

    ; y = 0 here

    ; copy over color infos
    lda SOFTCHARS_C, x
    sta (PTR_COLOR), y
    lda SOFTCHARS_S, x
    sta (PTR_SCREEN), y

    rts
}

!macro inc_wrap_around {
    ; is here a wrap-around of the buffers?
    lda PTR_COLOR + 1
    cmp # >(COLOR_RAM + $0400)
    bne +

    ; wrap around
    lda # >HIRES
    sta PTR_HIRES + 1

    lda # >SCREEN
    sta PTR_SCREEN + 1

    lda # >COLOR_RAM
    sta PTR_COLOR + 1
+
    rts
}

!macro dec_wrap_around {
    ; is here a wrap-around of the buffers?
    lda PTR_COLOR + 1
    cmp #(>COLOR_RAM) - 1
    bne +

    ; wrap around
    lda # >(HIRES + $1fff)
    sta PTR_HIRES + 1

    lda # >(SCREEN + $03ff)
    sta PTR_SCREEN + 1

    lda # >(COLOR_RAM + $03ff)
    sta PTR_COLOR + 1
+
    rts
}

; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one char postion
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
CHAR_INC_SCROLL_PTRS !zone {
    lda PTR_HIRES
    clc
    adc #8
    sta PTR_HIRES
    bcc .out_safely_inc_others  

    inc PTR_HIRES + 1   ; add carry to high byte

    ; PTR_SCREEN and PTR_COLOR _may_ overflow
    inc PTR_SCREEN
    inc PTR_COLOR

    ; do PTR_SCREEN and PTR_COLOR overflow, too?
    bne .out

    inc PTR_SCREEN + 1
    inc PTR_COLOR + 1

    +inc_wrap_around

.out_safely_inc_others

    ; PTR_SCREEN and PTR_COLOR _cannot_ overflow
    inc PTR_SCREEN
    inc PTR_COLOR

.out
    rts
}

; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one line position
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
LINE_INC_SCROLL_PTRS !zone {
    inc PTR_HIRES + 1   ; + 256
    lda PTR_HIRES
    clc
    adc #64-3*8
    sta PTR_HIRES
    bcc .out_safely_inc_others  

    inc PTR_HIRES + 1   ; add carry to high byte

    ; PTR_SCREEN and PTR_COLOR _may_ overflow
    lda #39-3
    adc PTR_SCREEN      ; carry still set, so add 40-3
    sec
    adc PTR_COLOR       ; also add 40-3

    ; do PTR_SCREEN and PTR_COLOR overflow, too?
    bcc .out

    inc PTR_SCREEN + 1
    inc PTR_COLOR + 1

    +inc_wrap_around

.out_safely_inc_others

    ; PTR_SCREEN and PTR_COLOR _cannot_ overflow
    lda #40
    adc PTR_COLOR   ; carry _is_ clear
    adc PTR_SCREEN  ; dito

.out
    rts
}

; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one char postion
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
CHAR_DEC_SCROLL_PTRS !zone {
    lda PTR_HIRES
    sec
    sbc #8
    sta PTR_HIRES
    ; TODO from here
    bcc .out_safely_inc_others  

    inc PTR_HIRES + 1   ; add carry to high byte

    ; PTR_SCREEN and PTR_COLOR _may_ overflow
    inc PTR_SCREEN
    inc PTR_COLOR

    ; do PTR_SCREEN and PTR_COLOR overflow, too?
    bne .out

    inc PTR_SCREEN + 1
    inc PTR_COLOR + 1

    +inc_wrap_around

.out_safely_inc_others

    ; PTR_SCREEN and PTR_COLOR _cannot_ overflow
    inc PTR_SCREEN
    inc PTR_COLOR

.out
    rts
}

; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one line position
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
LINE_DEC_SCROLL_PTRS !zone {
    inc PTR_HIRES + 1   ; + 256
    lda PTR_HIRES
    clc
    adc #64-3*8
    sta PTR_HIRES
    bcc .out_safely_inc_others  

    inc PTR_HIRES + 1   ; add carry to high byte

    ; PTR_SCREEN and PTR_COLOR _may_ overflow
    lda #39-3
    adc PTR_SCREEN      ; carry still set, so add 40-3
    sec
    adc PTR_COLOR       ; also add 40-3

    ; do PTR_SCREEN and PTR_COLOR overflow, too?
    bcc .out

    inc PTR_SCREEN + 1
    inc PTR_COLOR + 1

    +inc_wrap_around

.out_safely_inc_others

    ; PTR_SCREEN and PTR_COLOR _cannot_ overflow
    lda #40
    adc PTR_COLOR   ; carry _is_ clear
    adc PTR_SCREEN  ; dito

.out
    rts
}

DO_IT !zone {
    ; y -> col position
    lda (PTR_LEVEL), y      ; load tile index

    tay
    sty TMP_TILE_INDEX
    lda (PTR_TILE), y       ; load soft char index
    jsr COPY_SOFTCHARS
    jsr CHAR_INC_SCROLL_PTRS

    inc TMP_TILE_INDEX
    ldy TMP_TILE_INDEX
    lda (PTR_TILE), y       ; load soft char index
    jsr COPY_SOFTCHARS
    jsr CHAR_INC_SCROLL_PTRS

    inc TMP_TILE_INDEX
    ldy TMP_TILE_INDEX
    lda (PTR_TILE), y       ; load soft char index
    jsr COPY_SOFTCHARS
    jsr CHAR_INC_SCROLL_PTRS

    inc TMP_TILE_INDEX
    ldy TMP_TILE_INDEX
    lda (PTR_TILE), y       ; load soft char index
    jsr COPY_SOFTCHARS
    jsr LINE_INC_SCROLL_PTRS

    rts
}
