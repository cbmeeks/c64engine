; copy over softchar (index in A) to (PTR_HIRES), (PTR_COLOR), (PTR_SCREEN)
; destroys: A, X, Y
COPY_SOFTCHARS !zone {
    tax
    
    ; copy over soft char line by line
    ; y is used to index the row

    !for .j, 8 {
    !set .i = .j - 1
        
        !if .i = 0 {
            ldy #7
        } else {
            dey
        }

        lda SOFTCHARS + .i * $100, x
        sta (PTR_HIRES), y
    }

    ; y = 0 here

    ; copy over color infos
    lda SOFTCHARS_C, x
    sta (PTR_COLOR), y
    lda SOFTCHARS_S, x
    sta (PTR_SCREEN), y

    rts
}

!macro inc_wrap_around_rts {
    ; is here a wrap-around of the buffers?
    lda PTR_COLOR + 1
    cmp # >(COLOR_RAM + $0400)
    bne +

    ; wrap around
    lda # >HIRES
    sta PTR_HIRES + 1

    lda # >SCREEN
    sta PTR_SCREEN + 1

    lda # >COLOR_RAM
    sta PTR_COLOR + 1
+
    rts
}

!macro dec_wrap_around_rts {
    ; is here a wrap-around of the buffers?
    lda PTR_COLOR + 1
    cmp # >(COLOR_RAM - 1)
    ;bne +

    ; wrap around
    lda # >(HIRES + $2000 - 1)
    sta PTR_HIRES + 1

    lda # >(SCREEN + $0400 - 1)
    sta PTR_SCREEN + 1

    lda # >(COLOR_RAM + $0400 - 1)
    sta PTR_COLOR + 1
+
    rts
}

; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one char postion
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
CHAR_INC_SCROLL_PTRS !zone {
    lda PTR_HIRES
    clc
    adc #8
    sta PTR_HIRES
    bcc .out_safely_inc_others  

    inc PTR_HIRES + 1   ; add carry to high byte

    ; PTR_SCREEN and PTR_COLOR _may_ overflow
    inc PTR_SCREEN
    inc PTR_COLOR

    ; do PTR_SCREEN and PTR_COLOR overflow, too?
    bne .out

    inc PTR_SCREEN + 1
    inc PTR_COLOR + 1

    +inc_wrap_around_rts

.out_safely_inc_others

    ; PTR_SCREEN and PTR_COLOR _cannot_ overflow
    inc PTR_SCREEN
    inc PTR_COLOR

.out
    rts
}

; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one line position
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
LINE_INC_SCROLL_PTRS !zone {
    inc PTR_HIRES + 1   ; + 256
    lda PTR_HIRES
    clc
    adc #64-3*8
    sta PTR_HIRES
    bcc .out_safely_inc_others  

    inc PTR_HIRES + 1   ; add carry to high byte

    ; PTR_SCREEN and PTR_COLOR _may_ overflow
    lda #39-3
    adc PTR_SCREEN      ; carry still set, so add 40-3
    sec
    adc PTR_COLOR       ; also add 40-3

    ; do PTR_SCREEN and PTR_COLOR overflow, too?
    bcc .out

    inc PTR_SCREEN + 1
    inc PTR_COLOR + 1

    +inc_wrap_around_rts

.out_safely_inc_others

    ; PTR_SCREEN and PTR_COLOR _cannot_ overflow
    lda #40-3
    adc PTR_COLOR   ; carry _is_ clear
    adc PTR_SCREEN  ; dito

.out
    rts
}

; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one char postion
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
CHAR_DEC_SCROLL_PTRS !zone {
    lda PTR_HIRES
    sec
    sbc #8
    sta PTR_HIRES

    bcs .out_safely_dec_others  

    dec PTR_HIRES + 1   ; sub borrow from high byte
-
    ; PTR_SCREEN and PTR_COLOR _may_ underflow
    dec PTR_SCREEN
    dec PTR_COLOR

    ; do PTR_SCREEN and PTR_COLOR underflow, too?
    bne .out
    inc HIRES + 40*8*10
    inc HIRES + 40*8*15

    dec PTR_SCREEN + 1
    dec PTR_COLOR + 1

    +dec_wrap_around_rts

.out_safely_dec_others
    jmp -

    ; PTR_SCREEN and PTR_COLOR _cannot_ underflow
    dec PTR_SCREEN
    dec PTR_COLOR

.out
    rts
}

; adjust PTR_SCREEN, PTR_COLOR and PTR_SCREEN by one line position
; all necessary wrap-arounds are properly considered
; destroys: A
; preservers: X, Y
LINE_DEC_SCROLL_PTRS !zone {
    dec PTR_HIRES + 1   ; - 256
    lda PTR_HIRES
    sec
    sbc #64-3*8
    sta PTR_HIRES
    bcs .out_safely_dec_others  

    dec PTR_HIRES + 1   ; sub borrow from high byte

    ; PTR_SCREEN and PTR_COLOR _may_ underflow
    lda #39-3
    sbc PTR_SCREEN      ; carry still clear, so sub 40-3
    clc
    sbc PTR_COLOR       ; also add 40-3

    ; do PTR_SCREEN and PTR_COLOR underflow, too?
    bcc .out

    dec PTR_SCREEN + 1
    dec PTR_COLOR + 1

    +dec_wrap_around_rts

.out_safely_dec_others

    ; PTR_SCREEN and PTR_COLOR _cannot_ underflow
    lda #40-3
    sbc PTR_COLOR   ; carry _is_ clear
    sbc PTR_SCREEN  ; dito

.out
    rts
}

DO_IT !zone {
    ; y -> col position
    lda (PTR_LEVEL), y      ; load tile index

    tay
    sty TMP_TILE_INDEX
    lda (PTR_TILE), y       ; load soft char index
    jsr COPY_SOFTCHARS
    jsr CHAR_DEC_SCROLL_PTRS
    ;jsr CHAR_INC_SCROLL_PTRS

    inc TMP_TILE_INDEX
    ldy TMP_TILE_INDEX
    lda (PTR_TILE), y       ; load soft char index
    jsr COPY_SOFTCHARS
    jsr CHAR_DEC_SCROLL_PTRS
    ;jsr CHAR_INC_SCROLL_PTRS

    inc TMP_TILE_INDEX
    ldy TMP_TILE_INDEX
    lda (PTR_TILE), y       ; load soft char index
    jsr COPY_SOFTCHARS
    jsr CHAR_DEC_SCROLL_PTRS
    ;jsr CHAR_INC_SCROLL_PTRS

    inc TMP_TILE_INDEX
    ldy TMP_TILE_INDEX
    lda (PTR_TILE), y       ; load soft char index
    jsr COPY_SOFTCHARS
    jsr LINE_DEC_SCROLL_PTRS
    ;jsr CHAR_INC_SCROLL_PTRS

    rts
}
